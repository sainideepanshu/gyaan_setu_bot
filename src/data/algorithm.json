{
    "bubble sort": "function bubbleSort(arr) {\n    let len = arr.length;\n    for (let i = 0; i < len - 1; i++) {\n        for (let j = 0; j < len - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n    return arr;\n}",
    
    "selection sort": "function selectionSort(arr) {\n    let len = arr.length;\n    for (let i = 0; i < len - 1; i++) {\n        let minIndex = i;\n        for (let j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n    return arr;\n}",

    "insertion sort": "function insertionSort(arr) {\n    for (let i = 1; i < arr.length; i++) {\n        let key = arr[i];\n        let j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n    return arr;\n}",

    "merge sort": "function mergeSort(arr) {\n    if (arr.length < 2) return arr;\n    let mid = Math.floor(arr.length / 2);\n    let left = mergeSort(arr.slice(0, mid));\n    let right = mergeSort(arr.slice(mid));\n    return merge(left, right);\n}\nfunction merge(left, right) {\n    let result = [];\n    while (left.length && right.length) {\n        if (left[0] < right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n    return result.concat(left, right);\n}",

    "quick sort": "function quickSort(arr) {\n    if (arr.length < 2) return arr;\n    let pivot = arr[arr.length - 1];\n    let left = arr.filter((v, i) => v <= pivot && i !== arr.length - 1);\n    let right = arr.filter(v => v > pivot);\n    return [...quickSort(left), pivot, ...quickSort(right)];\n}",

    "heap sort": "function heapSort(arr) {\n    function heapify(arr, n, i) {\n        let largest = i;\n        let left = 2 * i + 1;\n        let right = 2 * i + 2;\n        if (left < n && arr[left] > arr[largest]) largest = left;\n        if (right < n && arr[right] > arr[largest]) largest = right;\n        if (largest !== i) {\n            [arr[i], arr[largest]] = [arr[largest], arr[i]];\n            heapify(arr, n, largest);\n        }\n    }\n    let n = arr.length;\n    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) heapify(arr, n, i);\n    for (let i = n - 1; i > 0; i--) {\n        [arr[0], arr[i]] = [arr[i], arr[0]];\n        heapify(arr, i, 0);\n    }\n    return arr;\n}",

    "counting sort": "function countingSort(arr, max) {\n    let count = new Array(max + 1).fill(0);\n    for (let num of arr) count[num]++;\n    let index = 0;\n    for (let i = 0; i <= max; i++) {\n        while (count[i]-- > 0) arr[index++] = i;\n    }\n    return arr;\n}",

    "radix sort": "function radixSort(arr) {\n    let max = Math.max(...arr);\n    let digitPlace = 1;\n    while (max / digitPlace > 0) {\n        arr = countingSortByDigit(arr, digitPlace);\n        digitPlace *= 10;\n    }\n    return arr;\n}\nfunction countingSortByDigit(arr, digitPlace) {\n    let count = new Array(10).fill(0);\n    let output = new Array(arr.length);\n    for (let num of arr) count[Math.floor(num / digitPlace) % 10]++;\n    for (let i = 1; i < 10; i++) count[i] += count[i - 1];\n    for (let i = arr.length - 1; i >= 0; i--) {\n        let digit = Math.floor(arr[i] / digitPlace) % 10;\n        output[--count[digit]] = arr[i];\n    }\n    return output;\n}",

    "bucket sort": "function bucketSort(arr, bucketSize = 5) {\n    if (arr.length === 0) return arr;\n    let min = Math.min(...arr), max = Math.max(...arr);\n    let bucketCount = Math.floor((max - min) / bucketSize) + 1;\n    let buckets = Array.from({ length: bucketCount }, () => []);\n    arr.forEach(num => buckets[Math.floor((num - min) / bucketSize)].push(num));\n    return buckets.flatMap(bucket => bucket.sort((a, b) => a - b));\n}",

    "linked list": "class ListNode {\n    constructor(value) {\n        this.value = value;\n        this.next = null;\n    }\n}\nclass LinkedList {\n    constructor() {\n        this.head = null;\n    }\n    append(value) {\n        let newNode = new ListNode(value);\n        if (!this.head) {\n            this.head = newNode;\n        } else {\n            let temp = this.head;\n            while (temp.next) temp = temp.next;\n            temp.next = newNode;\n        }\n    }\n}",

    "dynamic programming": "function fibonacci(n, memo = {}) {\n    if (n <= 1) return n;\n    if (memo[n]) return memo[n];\n    return memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n}\nfunction knapsack(weights, values, capacity) {\n    let dp = Array.from({ length: weights.length + 1 }, () => Array(capacity + 1).fill(0));\n    for (let i = 1; i <= weights.length; i++) {\n        for (let w = 0; w <= capacity; w++) {\n            dp[i][w] = weights[i - 1] > w ? dp[i - 1][w] : Math.max(dp[i - 1][w], values[i - 1] + dp[i - 1][w - weights[i - 1]]);\n        }\n    }\n    return dp[weights.length][capacity];\n}"
}
